## 关于递归和回溯方法求子集和问题的区别

- 递归方法求所有子集和的问题有点类似于生成一颗完全二叉树，每次递归到扩展结点，就是递归地生成一条选择这个结点或者不选择该结点的路径，最后的终止条件就是结点数大于等于n，代表着这颗二叉树终于走到了叶子结点

- 回溯方法要求找到子集和等于m的那一条路径，然后将这条路径用Y来保存，如果找到就直接输出，每次经过扩展结点的时候，都要判断是不是大于等于n，也就是是否走过了所有结点，如果超过了n就开始新一轮的回溯，如果小于n则进入进一轮的判断，判断新加入的结点之和是否会大于m，如果小于就选择该节点，如果大于就不选择

## insert函数默写

```C++
template<class T,class T2>
int Insert(T X[],int m,const T2 &v)
{
    int down=0;
    int up=m;
    while(down<up)
    {
        int mid = (down+up)/2;
        if(X[mid]==v)
        {
            return m;
        }
        else if(X[mid]>v)
        {
            up = mid;
        }
        else
        {
            down = mid+1;
        }
    }
    int i;
    for(i=m-1;i>0 and X[i]>v;--i)
    {
        X[i+1] = X[i];
    }
    X[i+1] = v;
    return m+1;
}
```

## 关于DFS求深度

- 在构造结构体的时候要多构造一个属性depth，用与存储每个节点的深度
- 在遇到空指针时，要返回0，即满足！x时
- 然后递归得到左右子树的最大深度，在此基础上进行加一操作得到本结点的深度

## 关于贪心求解装在问题

- 先将可变数组W按照升序排列
- 然后用可变数组X的布尔值表示是否装载该数
- 用变量rc表示剩余可装载量，用来中止循环